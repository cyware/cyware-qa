'''
copyright: Copyright (C) 2015-2022, KhulnaSoft Ltd.

           Created by Cyware, Inc. <info@khulnasoft.com>.

           This program is free software; you can redistribute it and/or modify it under the terms of GPLv2

type: integration

brief: The 'cyware-logcollector' daemon monitors configured files and commands for new log messages.
       Specifically, these tests will check if commands with different characteristics are executed
       correctly by the logcollector. They will also check if the 'info' and 'debug' lines are
       written in the logs when running these commands.
       Log data collection is the real-time process of making sense out of the records generated by
       servers or devices. This component can receive logs through text files or Windows event logs.
       It can also directly receive logs via remote syslog which is useful for firewalls and
       other such devices.

components:
    - logcollector

suite: command_monitoring

targets:
    - agent
    - manager

daemons:
    - cyware-logcollector

os_platform:
    - linux
    - macos
    - solaris

os_version:
    - Arch Linux
    - Amazon Linux 2
    - Amazon Linux 1
    - CentOS 8
    - CentOS 7
    - Debian Buster
    - Red Hat 8
    - Solaris 10
    - Solaris 11
    - macOS Catalina
    - macOS Server
    - Ubuntu Focal
    - Ubuntu Bionic

references:
    - https://documentation.cyware.khulnasoft.com/current/user-manual/capabilities/log-data-collection/index.html
    - https://documentation.cyware.khulnasoft.com/current/user-manual/reference/ossec-conf/localfile.html#command
    - https://documentation.cyware.khulnasoft.com/current/user-manual/reference/ossec-conf/localfile.html#alias
    - https://documentation.cyware.khulnasoft.com/current/user-manual/reference/ossec-conf/localfile.html#log-format

tags:
    - logcollector_cmd_exec
'''
import os
import pytest
import sys

from cyware_testing.tools import monitoring, LOG_FILE_PATH
from cyware_testing import global_parameters
import cyware_testing.logcollector as logcollector
from cyware_testing.tools.configuration import load_cyware_configurations
from cyware_testing.tools.monitoring import LOG_COLLECTOR_DETECTOR_PREFIX

# Marks
pytestmark = [pytest.mark.linux, pytest.mark.darwin, pytest.mark.sunos5, pytest.mark.tier(level=0)]

# Configuration
test_data_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'data')
configurations_path = os.path.join(test_data_path, 'cyware.khulnasoft.command_conf.yaml')

local_internal_options = {
    'logcollector.remote_commands': '1',
    'logcollector.max_lines': '100'
}

parameters = [
    {'LOG_FORMAT': 'command', 'COMMAND': 'echo', 'ALIAS': ''},
    {'LOG_FORMAT': 'command', 'COMMAND': 'echo hello world', 'ALIAS': 'goodbye'},
    {'LOG_FORMAT': 'command', 'COMMAND': 'not_found_command -o option -v', 'ALIAS': ''},
    {'LOG_FORMAT': 'command', 'COMMAND': f'tail -f {LOG_FILE_PATH}', 'ALIAS': ''},
    {'LOG_FORMAT': 'command', 'COMMAND': 'ls -R /tmp', 'ALIAS': ''},
    {'LOG_FORMAT': 'command', 'COMMAND': 'cat doesntexists.txt', 'ALIAS': ''},
    {'LOG_FORMAT': 'command', 'COMMAND': 'cat "ñ", "テスト", "ИСПЫТАНИЕ", "测试", "اختبار".txt', 'ALIAS': ''},
    {'LOG_FORMAT': 'command', 'COMMAND': 'テ``ñスト, ИСПЫТА´НИЕ",\'测`试", "اختبا', 'ALIAS': ''},
    {'LOG_FORMAT': 'command', 'COMMAND': 'echo ***', 'ALIAS': ''},
    {'LOG_FORMAT': 'full_command', 'COMMAND': 'echo', 'ALIAS': ''},
    {'LOG_FORMAT': 'full_command', 'COMMAND': 'echo hello world', 'ALIAS': 'goodbye'},
    {'LOG_FORMAT': 'full_command', 'COMMAND': 'not_found_command -o option -v', 'ALIAS': ''},
    {'LOG_FORMAT': 'full_command', 'COMMAND': f'tail -f {LOG_FILE_PATH}', 'ALIAS': ''},
    {'LOG_FORMAT': 'full_command', 'COMMAND': 'ls -R /tmp', 'ALIAS': ''},
    {'LOG_FORMAT': 'full_command', 'COMMAND': 'cat doesntexists.txt', 'ALIAS': ''},
    {'LOG_FORMAT': 'full_command', 'COMMAND': 'cat "ñ", "テスト", "ИСПЫТАНИЕ", "测试", "اختبار".txt', 'ALIAS': ''},
    {'LOG_FORMAT': 'full_command', 'COMMAND': 'テ``ñスト, ИСПЫТА´НИЕ",\'测`试", "اختبا', 'ALIAS': ''},
    {'LOG_FORMAT': 'full_command', 'COMMAND': 'echo ***', 'ALIAS': ''},
]
metadata = [
    {'log_format': 'command', 'command': 'echo', 'alias': '', 'info': 'empty_output'},
    {'log_format': 'command', 'command': 'echo hello world', 'alias': 'goodbye', 'info': 'check_output_and_alias'},
    {'log_format': 'command', 'command': 'not_found_command -o option -v', 'alias': '', 'info': 'not_found'},
    {'log_format': 'command', 'command': f'tail -f {LOG_FILE_PATH}', 'alias': '', 'info': 'does not end'},
    {'log_format': 'command', 'command': 'ls -R /tmp', 'alias': '', 'info': 'long_output'},
    {'log_format': 'command', 'command': 'cat doesntexists.txt', 'alias': '', 'info': 'that_fails'},
    {'log_format': 'command', 'command': 'cat "ñ", "テスト", "ИСПЫТАНИЕ", "测试", "اختبار".txt', 'alias': '',
     'info': 'special_chars_filename'},
    {'log_format': 'command', 'command': 'テ``ñスト, ИСПЫТА´НИЕ",\'测`试", "اختبا', 'alias': '',
     'info': 'special_chars_command'},
    {'log_format': 'command', 'command': 'echo ***', 'alias': '', 'info': 'special_chars_echo'},
    {'log_format': 'full_command', 'command': 'echo', 'alias': '', 'info': 'empty_output'},
    {'log_format': 'full_command', 'command': 'echo hello world', 'alias': 'goodbye', 'info': 'check_output_and_alias'},
    {'log_format': 'full_command', 'command': 'not_found_command -o option -v', 'alias': '', 'info': 'not_found'},
    {'log_format': 'full_command', 'command': f'tail -f {LOG_FILE_PATH}', 'alias': '', 'info': 'does not end'},
    {'log_format': 'full_command', 'command': 'ls -R /tmp', 'alias': '', 'info': 'long_output'},
    {'log_format': 'full_command', 'command': 'cat doesntexists.txt', 'alias': '', 'info': 'that_fails'},
    {'log_format': 'full_command', 'command': 'cat "ñ", "テスト", "ИСПЫТАНИЕ", "测试", "اختبار".txt', 'alias': '',
     'info': 'special_chars_filename'},
    {'log_format': 'full_command', 'command': 'テ``ñスト, ИСПЫТА´НИЕ",\'测`试", "اختبا', 'alias': '',
     'info': 'special_chars_command'},
    {'log_format': 'full_command', 'command': 'echo ***', 'alias': '', 'info': 'special_chars_echo'},
]

if sys.platform == 'linux':
    parameters.append({'LOG_FORMAT': 'command', 'COMMAND': 'timeout 2 tail -f /dev/random', 'ALIAS': 'killed_by_test'})
    parameters.append({'LOG_FORMAT': 'full_command', 'COMMAND': 'timeout 2 tail -f /dev/random', 'ALIAS': ''})
    parameters.append({'LOG_FORMAT': 'command', 'COMMAND': 'ss -l -p -u -t -4 -6 -n', 'ALIAS': ''})
    parameters.append({'LOG_FORMAT': 'full_command', 'COMMAND': 'ss -l -p -u -t -4 -6 -n', 'ALIAS': ''})
    metadata.append({'log_format': 'command', 'command': 'timeout 2 tail -f /dev/random', 'alias': '',
                     'info': 'killed_by_test'})
    metadata.append({'log_format': 'full_command', 'command': 'timeout 2 tail -f /dev/random', 'alias': '',
                     'info': 'killed_by_test'})
    metadata.append({'log_format': 'command', 'command': 'ss -l -p -u -t -4 -6 -n', 'alias': '',
                     'info': 'many_arguments'})
    metadata.append({'log_format': 'full_command', 'command': 'ss -l -p -u -t -4 -6 -n', 'alias': '',
                     'info': 'many_arguments'})

configurations = load_cyware_configurations(configurations_path, __name__, params=parameters, metadata=metadata)
configuration_ids = [f"{x['log_format']}_{x['info']}" for x in metadata]


# fixtures
@pytest.fixture(scope="module", params=configurations, ids=configuration_ids)
def get_configuration(request):
    """Get configurations from the module."""
    return request.param


def test_command_execution(configure_local_internal_options_module, get_configuration,
                           configure_environment, file_monitoring, restart_logcollector):
    '''
    description: Check if the 'cyware-logcollector' daemon runs commands with special characteristics.
                 For this purpose, the test will configure the logcollector to run a command, setting
                 it in the 'command' tag and using the 'command' and 'full_command' log formats.
                 The properties of that command can be, for example, a non-existent command or one that
                 includes special characters. Finally, the test will verify that the event, indicating
                 that the command is executed, has been generated.

    cyware_min_version: 4.2.0

    tier: 0

    parameters:
        - configure_local_internal_options_module:
            type: fixture
            brief: Configure the Cyware local internal options.
        - get_configuration:
            type: fixture
            brief: Get configurations from the module.
        - configure_environment:
            type: fixture
            brief: Configure a custom environment for testing.
        - file_monitoring:
            type: fixture
            brief: Handle the monitoring of a specified file.
        - restart_logcollector:
            type: fixture
            brief: Clear the 'ossec.log' file and start a new monitor.

    assertions:
        - Verify that the logcollector runs the command specified in the 'command' tag.

    input_description: A configuration template (test_command_execution) is contained in an external
                       YAML file (cyware.khulnasoft.command_conf.yaml), which includes configuration settings for
                       the 'cyware-logcollector' daemon and, it is combined with the test cases
                       (log formats and commands to run) defined in the module.

    expected_output:
        - r'.*cyware-logcollector.*' (this log must indicate the command executed)

    tags:
        - logs
    '''
    config = get_configuration['metadata']
    msg = config['command']

    cyware_log_monitor.start(timeout=global_parameters.default_timeout,
                            error_message=logcollector.GENERIC_CALLBACK_ERROR_COMMAND_MONITORING,
                            callback=monitoring.make_callback(pattern=msg,
                                                              prefix=LOG_COLLECTOR_DETECTOR_PREFIX,
                                                              escape=True))

    config = get_configuration['metadata']
    msg = config['command']

    log_monitor.start(timeout=global_parameters.default_timeout,
                      error_message=logcollector.GENERIC_CALLBACK_ERROR_COMMAND_MONITORING,
                      callback=monitoring.make_callback(pattern=msg,
                                                        prefix=LOG_COLLECTOR_DETECTOR_PREFIX,
                                                        escape=True))
